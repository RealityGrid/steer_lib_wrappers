/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.33
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTELC__)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1, 
  SWIG_JavaIOException, 
  SWIG_JavaRuntimeException, 
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" } };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  (*jenv)->ExceptionClear(jenv);
  excep = (*jenv)->FindClass(jenv, except_ptr->java_exception);
  if (excep)
    (*jenv)->ThrowNew(jenv, excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else


#include "ReG_Steer_Appside.h"
#include "ReG_Steer_Steerside.h"
#include "ReG_Steer_Browser.h"


typedef int Intp;

SWIGINTERN Intp *new_Intp(){
  return (int *) calloc(1,sizeof(int));
}
SWIGINTERN void delete_Intp(Intp *self){
  if (self) free(self);
}
SWIGINTERN void Intp_assign(Intp *self,int value){
  *self = value;
}
SWIGINTERN int Intp_value(Intp *self){
  return *self;
}
SWIGINTERN int *Intp_cast(Intp *self){
  return self;
}
SWIGINTERN Intp *Intp_frompointer(int *t){
  return (Intp *) t;
}

typedef char Charp;

SWIGINTERN Charp *new_Charp(){
  return (char *) calloc(1,sizeof(char));
}
SWIGINTERN void delete_Charp(Charp *self){
  if (self) free(self);
}
SWIGINTERN void Charp_assign(Charp *self,char value){
  *self = value;
}
SWIGINTERN char Charp_value(Charp *self){
  return *self;
}
SWIGINTERN char *Charp_cast(Charp *self){
  return self;
}
SWIGINTERN Charp *Charp_frompointer(char *t){
  return (Charp *) t;
}

typedef float Floatp;

SWIGINTERN Floatp *new_Floatp(){
  return (float *) calloc(1,sizeof(float));
}
SWIGINTERN void delete_Floatp(Floatp *self){
  if (self) free(self);
}
SWIGINTERN void Floatp_assign(Floatp *self,float value){
  *self = value;
}
SWIGINTERN float Floatp_value(Floatp *self){
  return *self;
}
SWIGINTERN float *Floatp_cast(Floatp *self){
  return self;
}
SWIGINTERN Floatp *Floatp_frompointer(float *t){
  return (Floatp *) t;
}

typedef double Doublep;

SWIGINTERN Doublep *new_Doublep(){
  return (double *) calloc(1,sizeof(double));
}
SWIGINTERN void delete_Doublep(Doublep *self){
  if (self) free(self);
}
SWIGINTERN void Doublep_assign(Doublep *self,double value){
  *self = value;
}
SWIGINTERN double Doublep_value(Doublep *self){
  return *self;
}
SWIGINTERN double *Doublep_cast(Doublep *self){
  return self;
}
SWIGINTERN Doublep *Doublep_frompointer(double *t){
  return (Doublep *) t;
}

#if defined(SWIG_NOINCLUDE) || defined(SWIG_NOARRAYS)


int SWIG_JavaArrayInSchar (JNIEnv *jenv, jbyte **jarr, signed char **carr, jbyteArray input);
void SWIG_JavaArrayArgoutSchar (JNIEnv *jenv, jbyte *jarr, signed char *carr, jbyteArray input);
jbyteArray SWIG_JavaArrayOutSchar (JNIEnv *jenv, signed char *result, jsize sz);


int SWIG_JavaArrayInUchar (JNIEnv *jenv, jshort **jarr, unsigned char **carr, jshortArray input);
void SWIG_JavaArrayArgoutUchar (JNIEnv *jenv, jshort *jarr, unsigned char *carr, jshortArray input);
jshortArray SWIG_JavaArrayOutUchar (JNIEnv *jenv, unsigned char *result, jsize sz);


int SWIG_JavaArrayInShort (JNIEnv *jenv, jshort **jarr, short **carr, jshortArray input);
void SWIG_JavaArrayArgoutShort (JNIEnv *jenv, jshort *jarr, short *carr, jshortArray input);
jshortArray SWIG_JavaArrayOutShort (JNIEnv *jenv, short *result, jsize sz);


int SWIG_JavaArrayInUshort (JNIEnv *jenv, jint **jarr, unsigned short **carr, jintArray input);
void SWIG_JavaArrayArgoutUshort (JNIEnv *jenv, jint *jarr, unsigned short *carr, jintArray input);
jintArray SWIG_JavaArrayOutUshort (JNIEnv *jenv, unsigned short *result, jsize sz);


int SWIG_JavaArrayInInt (JNIEnv *jenv, jint **jarr, int **carr, jintArray input);
void SWIG_JavaArrayArgoutInt (JNIEnv *jenv, jint *jarr, int *carr, jintArray input);
jintArray SWIG_JavaArrayOutInt (JNIEnv *jenv, int *result, jsize sz);


int SWIG_JavaArrayInUint (JNIEnv *jenv, jlong **jarr, unsigned int **carr, jlongArray input);
void SWIG_JavaArrayArgoutUint (JNIEnv *jenv, jlong *jarr, unsigned int *carr, jlongArray input);
jlongArray SWIG_JavaArrayOutUint (JNIEnv *jenv, unsigned int *result, jsize sz);


int SWIG_JavaArrayInLong (JNIEnv *jenv, jint **jarr, long **carr, jintArray input);
void SWIG_JavaArrayArgoutLong (JNIEnv *jenv, jint *jarr, long *carr, jintArray input);
jintArray SWIG_JavaArrayOutLong (JNIEnv *jenv, long *result, jsize sz);


int SWIG_JavaArrayInUlong (JNIEnv *jenv, jlong **jarr, unsigned long **carr, jlongArray input);
void SWIG_JavaArrayArgoutUlong (JNIEnv *jenv, jlong *jarr, unsigned long *carr, jlongArray input);
jlongArray SWIG_JavaArrayOutUlong (JNIEnv *jenv, unsigned long *result, jsize sz);


int SWIG_JavaArrayInLonglong (JNIEnv *jenv, jlong **jarr, jlong **carr, jlongArray input);
void SWIG_JavaArrayArgoutLonglong (JNIEnv *jenv, jlong *jarr, jlong *carr, jlongArray input);
jlongArray SWIG_JavaArrayOutLonglong (JNIEnv *jenv, jlong *result, jsize sz);


int SWIG_JavaArrayInFloat (JNIEnv *jenv, jfloat **jarr, float **carr, jfloatArray input);
void SWIG_JavaArrayArgoutFloat (JNIEnv *jenv, jfloat *jarr, float *carr, jfloatArray input);
jfloatArray SWIG_JavaArrayOutFloat (JNIEnv *jenv, float *result, jsize sz);


int SWIG_JavaArrayInDouble (JNIEnv *jenv, jdouble **jarr, double **carr, jdoubleArray input);
void SWIG_JavaArrayArgoutDouble (JNIEnv *jenv, jdouble *jarr, double *carr, jdoubleArray input);
jdoubleArray SWIG_JavaArrayOutDouble (JNIEnv *jenv, double *result, jsize sz);


#else


/* signed char[] support */
int SWIG_JavaArrayInSchar (JNIEnv *jenv, jbyte **jarr, signed char **carr, jbyteArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetByteArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (signed char*) calloc(sz, sizeof(signed char)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (signed char)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutSchar (JNIEnv *jenv, jbyte *jarr, signed char *carr, jbyteArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jbyte)carr[i];
  (*jenv)->ReleaseByteArrayElements(jenv, input, jarr, 0);
}

jbyteArray SWIG_JavaArrayOutSchar (JNIEnv *jenv, signed char *result, jsize sz) {
  jbyte *arr;
  int i;
  jbyteArray jresult = (*jenv)->NewByteArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetByteArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jbyte)result[i];
  (*jenv)->ReleaseByteArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* unsigned char[] support */
int SWIG_JavaArrayInUchar (JNIEnv *jenv, jshort **jarr, unsigned char **carr, jshortArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetShortArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (unsigned char*) calloc(sz, sizeof(unsigned char)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned char)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutUchar (JNIEnv *jenv, jshort *jarr, unsigned char *carr, jshortArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jshort)carr[i];
  (*jenv)->ReleaseShortArrayElements(jenv, input, jarr, 0);
}

jshortArray SWIG_JavaArrayOutUchar (JNIEnv *jenv, unsigned char *result, jsize sz) {
  jshort *arr;
  int i;
  jshortArray jresult = (*jenv)->NewShortArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetShortArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jshort)result[i];
  (*jenv)->ReleaseShortArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* short[] support */
int SWIG_JavaArrayInShort (JNIEnv *jenv, jshort **jarr, short **carr, jshortArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetShortArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (short*) calloc(sz, sizeof(short)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (short)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutShort (JNIEnv *jenv, jshort *jarr, short *carr, jshortArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jshort)carr[i];
  (*jenv)->ReleaseShortArrayElements(jenv, input, jarr, 0);
}

jshortArray SWIG_JavaArrayOutShort (JNIEnv *jenv, short *result, jsize sz) {
  jshort *arr;
  int i;
  jshortArray jresult = (*jenv)->NewShortArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetShortArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jshort)result[i];
  (*jenv)->ReleaseShortArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* unsigned short[] support */
int SWIG_JavaArrayInUshort (JNIEnv *jenv, jint **jarr, unsigned short **carr, jintArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (unsigned short*) calloc(sz, sizeof(unsigned short)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned short)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutUshort (JNIEnv *jenv, jint *jarr, unsigned short *carr, jintArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];
  (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
}

jintArray SWIG_JavaArrayOutUshort (JNIEnv *jenv, unsigned short *result, jsize sz) {
  jint *arr;
  int i;
  jintArray jresult = (*jenv)->NewIntArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jint)result[i];
  (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* int[] support */
int SWIG_JavaArrayInInt (JNIEnv *jenv, jint **jarr, int **carr, jintArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (int*) calloc(sz, sizeof(int)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (int)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutInt (JNIEnv *jenv, jint *jarr, int *carr, jintArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];
  (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
}

jintArray SWIG_JavaArrayOutInt (JNIEnv *jenv, int *result, jsize sz) {
  jint *arr;
  int i;
  jintArray jresult = (*jenv)->NewIntArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jint)result[i];
  (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* unsigned int[] support */
int SWIG_JavaArrayInUint (JNIEnv *jenv, jlong **jarr, unsigned int **carr, jlongArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (unsigned int*) calloc(sz, sizeof(unsigned int)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned int)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutUint (JNIEnv *jenv, jlong *jarr, unsigned int *carr, jlongArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];
  (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
}

jlongArray SWIG_JavaArrayOutUint (JNIEnv *jenv, unsigned int *result, jsize sz) {
  jlong *arr;
  int i;
  jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jlong)result[i];
  (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* long[] support */
int SWIG_JavaArrayInLong (JNIEnv *jenv, jint **jarr, long **carr, jintArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (long*) calloc(sz, sizeof(long)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (long)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutLong (JNIEnv *jenv, jint *jarr, long *carr, jintArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jint)carr[i];
  (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
}

jintArray SWIG_JavaArrayOutLong (JNIEnv *jenv, long *result, jsize sz) {
  jint *arr;
  int i;
  jintArray jresult = (*jenv)->NewIntArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jint)result[i];
  (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* unsigned long[] support */
int SWIG_JavaArrayInUlong (JNIEnv *jenv, jlong **jarr, unsigned long **carr, jlongArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (unsigned long*) calloc(sz, sizeof(unsigned long)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (unsigned long)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutUlong (JNIEnv *jenv, jlong *jarr, unsigned long *carr, jlongArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];
  (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
}

jlongArray SWIG_JavaArrayOutUlong (JNIEnv *jenv, unsigned long *result, jsize sz) {
  jlong *arr;
  int i;
  jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jlong)result[i];
  (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* jlong[] support */
int SWIG_JavaArrayInLonglong (JNIEnv *jenv, jlong **jarr, jlong **carr, jlongArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (jlong*) calloc(sz, sizeof(jlong)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (jlong)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutLonglong (JNIEnv *jenv, jlong *jarr, jlong *carr, jlongArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jlong)carr[i];
  (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
}

jlongArray SWIG_JavaArrayOutLonglong (JNIEnv *jenv, jlong *result, jsize sz) {
  jlong *arr;
  int i;
  jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jlong)result[i];
  (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* float[] support */
int SWIG_JavaArrayInFloat (JNIEnv *jenv, jfloat **jarr, float **carr, jfloatArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetFloatArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (float*) calloc(sz, sizeof(float)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (float)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutFloat (JNIEnv *jenv, jfloat *jarr, float *carr, jfloatArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jfloat)carr[i];
  (*jenv)->ReleaseFloatArrayElements(jenv, input, jarr, 0);
}

jfloatArray SWIG_JavaArrayOutFloat (JNIEnv *jenv, float *result, jsize sz) {
  jfloat *arr;
  int i;
  jfloatArray jresult = (*jenv)->NewFloatArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetFloatArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jfloat)result[i];
  (*jenv)->ReleaseFloatArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


/* double[] support */
int SWIG_JavaArrayInDouble (JNIEnv *jenv, jdouble **jarr, double **carr, jdoubleArray input) {
  int i;
  jsize sz;
  if (!input) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
    return 0;
  }
  sz = (*jenv)->GetArrayLength(jenv, input);
  *jarr = (*jenv)->GetDoubleArrayElements(jenv, input, 0);
  if (!*jarr)
    return 0; 
  *carr = (double*) calloc(sz, sizeof(double)); 
  if (!*carr) {
    SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
    return 0;
  }
  for (i=0; i<sz; i++)
    (*carr)[i] = (double)(*jarr)[i];
  return 1;
}

void SWIG_JavaArrayArgoutDouble (JNIEnv *jenv, jdouble *jarr, double *carr, jdoubleArray input) {
  int i;
  jsize sz = (*jenv)->GetArrayLength(jenv, input);
  for (i=0; i<sz; i++)
    jarr[i] = (jdouble)carr[i];
  (*jenv)->ReleaseDoubleArrayElements(jenv, input, jarr, 0);
}

jdoubleArray SWIG_JavaArrayOutDouble (JNIEnv *jenv, double *result, jsize sz) {
  jdouble *arr;
  int i;
  jdoubleArray jresult = (*jenv)->NewDoubleArray(jenv, sz);
  if (!jresult)
    return NULL;
  arr = (*jenv)->GetDoubleArrayElements(jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jdouble)result[i];
  (*jenv)->ReleaseDoubleArrayElements(jenv, jresult, arr, 0);
  return jresult;
}


#endif


  int Sizeof(int type) {
    int result;
    switch(type) {
    case REG_INT:
      result = sizeof(int);
      break;
    case REG_CHAR:
      result = sizeof(char);
      break;
    case REG_FLOAT:
      result = sizeof(float);
      break;
    case REG_DBL:
      result = sizeof(double);
      break;
    case REG_XDR_INT:
      result = REG_SIZEOF_XDR_INT;
      break;
    case REG_XDR_FLOAT:
      result = REG_SIZEOF_XDR_FLOAT;
      break;
    case REG_XDR_DOUBLE:
      result = REG_SIZEOF_XDR_DOUBLE;
      break;
    default:
      result = 0;
      break;
    }

    return result;
  }


  jobject Consume_data_slice_j(int IOTypeIndex, int DataType, int Count, void* pDataOUT) {
    Consume_data_slice(IOTypeIndex, DataType, Count, pDataOUT);
    return 0;
  }


  jobjectArray Get_param_values_j(int sim_handle, int steerable, int num_params, Param_details_struct *param_details) {
    Get_param_values(sim_handle, steerable, num_params, param_details);
    return 0;
  }


  jobject Get_security_config_j(const char* configFile,
				struct reg_security_info* secOut) {
    Get_security_config(configFile, secOut);
    return 0;
  }


  jobjectArray Get_registry_entries_secure_j(const char* registryGSH,
				       const struct reg_security_info* secIn,
				       struct registry_contents* regContsOut) {
    Get_registry_entries_secure(registryGSH, secIn, regContsOut);
  }


  jobjectArray Get_registry_entries_filtered_secure_j(const char* registryGSH,
				       const struct reg_security_info* secIn,
				       struct registry_contents* regContsOut,
				       char* pattern) {
    Get_registry_entries_filtered_secure(registryGSH, secIn, regContsOut, pattern);
  }


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_new_1Intp(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  Intp *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (Intp *)new_Intp();
  *(Intp **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_delete_1Intp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Intp *arg1 = (Intp *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Intp **)&jarg1; 
  delete_Intp(arg1);
  
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Intp_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  Intp *arg1 = (Intp *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Intp **)&jarg1; 
  arg2 = (int)jarg2; 
  Intp_assign(arg1,arg2);
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Intp_1value(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  Intp *arg1 = (Intp *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Intp **)&jarg1; 
  result = (int)Intp_value(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Intp_1cast(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Intp *arg1 = (Intp *) 0 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Intp **)&jarg1; 
  result = (int *)Intp_cast(arg1);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Intp_1frompointer(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  int *arg1 = (int *) 0 ;
  Intp *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(int **)&jarg1; 
  result = (Intp *)Intp_frompointer(arg1);
  *(Intp **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_new_1Charp(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  Charp *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (Charp *)new_Charp();
  *(Charp **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_delete_1Charp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Charp *arg1 = (Charp *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Charp **)&jarg1; 
  delete_Charp(arg1);
  
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Charp_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  Charp *arg1 = (Charp *) 0 ;
  char arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Charp **)&jarg1; 
  arg2 = (char)jarg2; 
  Charp_assign(arg1,arg2);
}


SWIGEXPORT jchar JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Charp_1value(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jchar jresult = 0 ;
  Charp *arg1 = (Charp *) 0 ;
  char result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Charp **)&jarg1; 
  result = (char)Charp_value(arg1);
  jresult = (jchar)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Charp_1cast(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  Charp *arg1 = (Charp *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Charp **)&jarg1; 
  result = (char *)Charp_cast(arg1);
  if(result) jresult = (*jenv)->NewStringUTF(jenv, (const char *)result);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Charp_1frompointer(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  Charp *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  result = (Charp *)Charp_frompointer(arg1);
  *(Charp **)&jresult = result; 
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_new_1Floatp(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  Floatp *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (Floatp *)new_Floatp();
  *(Floatp **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_delete_1Floatp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Floatp *arg1 = (Floatp *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Floatp **)&jarg1; 
  delete_Floatp(arg1);
  
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Floatp_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
  Floatp *arg1 = (Floatp *) 0 ;
  float arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Floatp **)&jarg1; 
  arg2 = (float)jarg2; 
  Floatp_assign(arg1,arg2);
}


SWIGEXPORT jfloat JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Floatp_1value(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jfloat jresult = 0 ;
  Floatp *arg1 = (Floatp *) 0 ;
  float result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Floatp **)&jarg1; 
  result = (float)Floatp_value(arg1);
  jresult = (jfloat)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Floatp_1cast(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Floatp *arg1 = (Floatp *) 0 ;
  float *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Floatp **)&jarg1; 
  result = (float *)Floatp_cast(arg1);
  *(float **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Floatp_1frompointer(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  float *arg1 = (float *) 0 ;
  Floatp *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(float **)&jarg1; 
  result = (Floatp *)Floatp_frompointer(arg1);
  *(Floatp **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_new_1Doublep(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  Doublep *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (Doublep *)new_Doublep();
  *(Doublep **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_delete_1Doublep(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Doublep *arg1 = (Doublep *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Doublep **)&jarg1; 
  delete_Doublep(arg1);
  
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Doublep_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  Doublep *arg1 = (Doublep *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Doublep **)&jarg1; 
  arg2 = (double)jarg2; 
  Doublep_assign(arg1,arg2);
}


SWIGEXPORT jdouble JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Doublep_1value(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  Doublep *arg1 = (Doublep *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Doublep **)&jarg1; 
  result = (double)Doublep_value(arg1);
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Doublep_1cast(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Doublep *arg1 = (Doublep *) 0 ;
  double *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Doublep **)&jarg1; 
  result = (double *)Doublep_cast(arg1);
  *(double **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Doublep_1frompointer(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  double *arg1 = (double *) 0 ;
  Doublep *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(double **)&jarg1; 
  result = (Doublep *)Doublep_frompointer(arg1);
  *(Doublep **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Steering_1enable(JNIEnv *jenv, jclass jcls, jint jarg1) {
  int arg1 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  Steering_enable(arg1);
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Steering_1initialize(JNIEnv *jenv, jclass jcls, jstring jarg1, jintArray jarg2) {
  jint jresult = 0 ;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  {
    arg2 = (int) (*jenv)->GetArrayLength(jenv, jarg2);
    arg3 = (int*) (*jenv)->GetIntArrayElements(jenv, jarg2, 0);
  }
  result = (int)Steering_initialize(arg1,arg2,arg3);
  jresult = (jint)result; 
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  {
    if(arg3) (*jenv)->ReleaseIntArrayElements(jenv, jarg2, arg3, JNI_ABORT);
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Register_1IOType(JNIEnv *jenv, jclass jcls, jstring jarg1, jint jarg2, jint jarg3, jlong jarg4) {
  jint jresult = 0 ;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  int *arg4 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = *(int **)&jarg4; 
  result = (int)Register_IOType(arg1,arg2,arg3,arg4);
  jresult = (jint)result; 
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Enable_1IOTypes_1on_1registration(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Enable_IOTypes_on_registration(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Disable_1IOType(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Disable_IOType(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Enable_1IOType(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Enable_IOType(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Enable_1IOType_1acks(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Enable_IOType_acks(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Disable_1IOType_1acks(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Disable_IOType_acks(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Register_1param(JNIEnv *jenv, jclass jcls, jstring jarg1, jint jarg2, jlong jarg3, jint jarg4, jstring jarg5, jstring jarg6) {
  jint jresult = 0 ;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  void *arg3 = (void *) 0 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  char *arg6 = (char *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  arg2 = (int)jarg2; 
  arg3 = *(void **)&jarg3; 
  arg4 = (int)jarg4; 
  arg5 = 0;
  if (jarg5) {
    arg5 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg5, 0);
    if (!arg5) return 0;
  }
  arg6 = 0;
  if (jarg6) {
    arg6 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg6, 0);
    if (!arg6) return 0;
  }
  result = (int)Register_param(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = (jint)result; 
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  if (arg5) (*jenv)->ReleaseStringUTFChars(jenv, jarg5, (const char *)arg5);
  if (arg6) (*jenv)->ReleaseStringUTFChars(jenv, jarg6, (const char *)arg6);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Steering_1control(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2, jobjectArray jarg3, jlong jarg4, jintArray jarg5, jobjectArray jarg6) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  char **arg6 = (char **) 0 ;
  int result;
  jint len3 ;
  jint *jarr5 ;
  jint len6 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  {
    int i;
    if(!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    
    len3 = (*jenv)->GetArrayLength(jenv, jarg3);
    arg3 = (char**) malloc(len3 * sizeof(char*));
    for(i = 0; i < len3; i++) {
      arg3[i] = (char*) malloc(256 * sizeof(char));
    }
  }
  arg4 = *(int **)&jarg4; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr5, &arg5, jarg5)) return 0; 
  {
    int i;
    if(!jarg6) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    
    len6 = (*jenv)->GetArrayLength(jenv, jarg6);
    arg6 = (char**) malloc(len6 * sizeof(char*));
    for(i = 0; i < len6; i++) {
      arg6[i] = (char*) malloc(256 * sizeof(char));
    }
  }
  result = (int)Steering_control(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = (jint)result; 
  {
    int i;
    jstring temp_string;
    for(i = 0; i < len3; i++) {
      temp_string = (*jenv)->NewStringUTF(jenv, arg3[i]);
      (*jenv)->SetObjectArrayElement(jenv, jarg3, i, temp_string);
      (*jenv)->DeleteLocalRef(jenv, temp_string);
    }
  }
  SWIG_JavaArrayArgoutInt(jenv, jarr5, arg5, jarg5); 
  {
    int i;
    jstring temp_string;
    for(i = 0; i < len6; i++) {
      temp_string = (*jenv)->NewStringUTF(jenv, arg6[i]);
      (*jenv)->SetObjectArrayElement(jenv, jarg6, i, temp_string);
      (*jenv)->DeleteLocalRef(jenv, temp_string);
    }
  }
  {
    int i;
    for(i = 0; i < len3; i++) 
    if(arg3[i]) free(arg3[i]);
    if(arg3) free(arg3);
  }
  free(arg5); 
  {
    int i;
    for(i = 0; i < len6; i++) 
    if(arg6[i]) free(arg6[i]);
    if(arg6) free(arg6);
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1start(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jlong jarg3) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = *(int **)&jarg3; 
  result = (int)Emit_start(arg1,arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1start_1blocking(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jlong jarg3, jfloat jarg4) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  float arg4 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = *(int **)&jarg3; 
  arg4 = (float)jarg4; 
  result = (int)Emit_start_blocking(arg1,arg2,arg3,arg4);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1data_1slice(JNIEnv *jenv, jclass jcls, jint jarg1, jobject jarg4) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  {
    /* Just throw these away as we can work them out! */
  }
  arg1 = (int)jarg1; 
  arg4 = *(void **)&jarg4; 
  {
    if((*jenv)->IsInstanceOf(jenv, jarg4, (*jenv)->FindClass(jenv, "[I")) == JNI_TRUE) {
      arg2 = 0;
      arg3 = (*jenv)->GetArrayLength(jenv, jarg4);
      arg4 = (int*) malloc(arg3 * sizeof(int));
      (*jenv)->GetIntArrayRegion(jenv, jarg4, 0, arg3, arg4);
    }
    else if((*jenv)->IsInstanceOf(jenv, jarg4, (*jenv)->FindClass(jenv, "[F")) == JNI_TRUE) {
      arg2 = 1;
      arg3 = (*jenv)->GetArrayLength(jenv, jarg4);
      arg4 = (float*) malloc(arg3 * sizeof(float));
      (*jenv)->GetFloatArrayRegion(jenv, jarg4, 0, arg3, arg4);
    }
    else if((*jenv)->IsInstanceOf(jenv, jarg4, (*jenv)->FindClass(jenv, "[D")) == JNI_TRUE) {
      arg2 = 2;
      arg3 = (*jenv)->GetArrayLength(jenv, jarg4);
      arg4 = (double*) malloc(arg3 * sizeof(double));
      (*jenv)->GetDoubleArrayRegion(jenv, jarg4, 0, arg3, arg4);
    }
    else if((*jenv)->IsInstanceOf(jenv, jarg4, (*jenv)->FindClass(jenv, "[B")) == JNI_TRUE) {
      arg2 = 3;
      arg3 = (*jenv)->GetArrayLength(jenv, jarg4);
      arg4 = (char*) malloc(arg3 * sizeof(char));
      (*jenv)->GetByteArrayRegion(jenv, jarg4, 0, arg3, arg4);
    }
    else if((*jenv)->IsInstanceOf(jenv, jarg4, (*jenv)->FindClass(jenv, "java/lang/String")) == JNI_TRUE) {
      jboolean isCopy;
      
      arg2 = 3;
      arg3 = (*jenv)->GetStringUTFLength(jenv, jarg4) + 1;
      arg4 = (char*) malloc(arg3 * sizeof(char));
      const char* cArray = (*jenv)->GetStringUTFChars(jenv, jarg4, &isCopy);
      strncpy(arg4, cArray, arg3);
      if(isCopy == JNI_TRUE)
      (*jenv)->ReleaseStringUTFChars(jenv, jarg4, cArray);
    }
  }
  result = (int)Emit_data_slice(arg1,arg2,arg3,(void const *)arg4);
  jresult = (jint)result; 
  {
    if(arg4) free(arg4);
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1stop(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jint jresult = 0 ;
  int *arg1 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(int **)&jarg1; 
  result = (int)Emit_stop(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1start(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  result = (int)Consume_start(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1start_1blocking(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2, jfloat jarg3) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  float arg3 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  arg3 = (float)jarg3; 
  result = (int)Consume_start_blocking(arg1,arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1data_1slice_1header(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2, jlong jarg3) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  arg3 = *(int **)&jarg3; 
  result = (int)Consume_data_slice_header(arg1,arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1stop(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jint jresult = 0 ;
  int *arg1 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(int **)&jarg1; 
  result = (int)Consume_stop(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Steering_1finalize(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)Steering_finalize();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Sizeof(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Sizeof(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Steerer_1initialize(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)Steerer_initialize();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Steerer_1finalize(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)Steerer_finalize();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1sim_1list(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2, jobjectArray jarg3) {
  jint jresult = 0 ;
  int *arg1 = (int *) 0 ;
  char **arg2 = (char **) 0 ;
  char **arg3 = (char **) 0 ;
  int result;
  jint len2 ;
  jint len3 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(int **)&jarg1; 
  {
    int i;
    if(!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    
    len2 = (*jenv)->GetArrayLength(jenv, jarg2);
    arg2 = (char**) malloc(len2 * sizeof(char*));
    for(i = 0; i < len2; i++) {
      arg2[i] = (char*) malloc(256 * sizeof(char));
    }
  }
  {
    int i;
    if(!jarg3) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    
    len3 = (*jenv)->GetArrayLength(jenv, jarg3);
    arg3 = (char**) malloc(len3 * sizeof(char*));
    for(i = 0; i < len3; i++) {
      arg3[i] = (char*) malloc(256 * sizeof(char));
    }
  }
  result = (int)Get_sim_list(arg1,arg2,arg3);
  jresult = (jint)result; 
  {
    int i;
    jstring temp_string;
    for(i = 0; i < len2; i++) {
      temp_string = (*jenv)->NewStringUTF(jenv, arg2[i]);
      (*jenv)->SetObjectArrayElement(jenv, jarg2, i, temp_string);
      (*jenv)->DeleteLocalRef(jenv, temp_string);
    }
  }
  {
    int i;
    jstring temp_string;
    for(i = 0; i < len3; i++) {
      temp_string = (*jenv)->NewStringUTF(jenv, arg3[i]);
      (*jenv)->SetObjectArrayElement(jenv, jarg3, i, temp_string);
      (*jenv)->DeleteLocalRef(jenv, temp_string);
    }
  }
  {
    int i;
    for(i = 0; i < len2; i++) 
    if(arg2[i]) free(arg2[i]);
    if(arg2) free(arg2);
  }
  {
    int i;
    for(i = 0; i < len3; i++) 
    if(arg3[i]) free(arg3[i]);
    if(arg3) free(arg3);
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Sim_1attach(JNIEnv *jenv, jclass jcls, jstring jarg1, jlong jarg2) {
  jint jresult = 0 ;
  char *arg1 = (char *) 0 ;
  int *arg2 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  arg2 = *(int **)&jarg2; 
  result = (int)Sim_attach(arg1,arg2);
  jresult = (jint)result; 
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Sim_1attach_1secure(JNIEnv *jenv, jclass jcls, jstring jarg1, jobject jarg2, jlong jarg3) {
  jint jresult = 0 ;
  char *arg1 = (char *) 0 ;
  struct reg_security_info *arg2 = (struct reg_security_info *) 0 ;
  int *arg3 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  {
    jclass regSec;
    jmethodID getMethod;
    jboolean usingSSL;
    jboolean isStringCopy;
    jobject secString;
    const char* cString;
    
    // malloc C security struct
    arg2 = 0;
    arg2 = (struct reg_security_info*) malloc(sizeof(struct reg_security_info));
    if(!arg2) return 0;
    
    // get Java security class
    regSec = (*jenv)->FindClass(jenv, "org/realitygrid/steering/ReG_SteerSecurity");
    
    // use_ssl?
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "isUsingSSL", "()Z");
    usingSSL = (*jenv)->CallBooleanMethod(jenv, jarg2, getMethod);
    arg2->use_ssl = (usingSSL == JNI_TRUE) ? 1 : 0;
    
    // caCertsPath
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getCaCertsPath", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->caCertsPath, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // myKeyCertFile
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getMyKeyCertFile", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->myKeyCertFile, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // userDN
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getUserDN", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->userDN, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // passphrase
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getPassphrase", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->passphrase, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
  }
  arg3 = *(int **)&jarg3; 
  result = (int)Sim_attach_secure((char const *)arg1,(struct reg_security_info const *)arg2,arg3);
  jresult = (jint)result; 
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  {
    if(arg2) free(arg2);
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Sim_1detach(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jint jresult = 0 ;
  int *arg1 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(int **)&jarg1; 
  result = (int)Sim_detach(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Delete_1sim_1table_1entry(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jint jresult = 0 ;
  int *arg1 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(int **)&jarg1; 
  result = (int)Delete_sim_table_entry(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1param_1defs(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Consume_param_defs(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1param_1number(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jlong jarg3) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = *(int **)&jarg3; 
  result = (int)Get_param_number(arg1,arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Set_1param_1values(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jintArray jarg3, jobjectArray jarg4) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  char **arg4 = (char **) 0 ;
  int result;
  jint *jarr3 ;
  jint len4 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr3, &arg3, jarg3)) return 0; 
  {
    int i;
    if(!jarg4) {
      arg4 = NULL;
      len4 = 0;
    }
    else {
      len4 = (*jenv)->GetArrayLength(jenv, jarg4);
      arg4 = (char**) malloc((len4 + 1) * sizeof(char*));
      /* make a copy of each string */
      for(i = 0; i < len4; i++) {
        jstring jString = (jstring)(*jenv)->GetObjectArrayElement(jenv, jarg4, i);
        const char* cString = (*jenv)->GetStringUTFChars(jenv, jString, 0);
        arg4[i] = malloc(strlen((cString) + 1) * sizeof(const char*));
        strcpy(arg4[i], cString);
        (*jenv)->ReleaseStringUTFChars(jenv, jString, cString);
        (*jenv)->DeleteLocalRef(jenv, jString);
      }
      arg4[i] = 0;
    }
  }
  result = (int)Set_param_values(arg1,arg2,arg3,arg4);
  jresult = (jint)result; 
  SWIG_JavaArrayArgoutInt(jenv, jarr3, arg3, jarg3); 
  free(arg3); 
  {
    int i;
    for(i = 0; i < len4-1; i++)
    if(arg4[i]) free(arg4[i]);
    if(arg4) free(arg4);
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1IOType_1defs(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Consume_IOType_defs(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1iotype_1number(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  result = (int)Get_iotype_number(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1iotypes(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jintArray jarg3, jobjectArray jarg4, jintArray jarg5, jintArray jarg6) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  char **arg4 = (char **) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int result;
  jint *jarr3 ;
  jint len4 ;
  jint *jarr5 ;
  jint *jarr6 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr3, &arg3, jarg3)) return 0; 
  {
    int i;
    if(!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    
    len4 = (*jenv)->GetArrayLength(jenv, jarg4);
    arg4 = (char**) malloc(len4 * sizeof(char*));
    for(i = 0; i < len4; i++) {
      arg4[i] = (char*) malloc(256 * sizeof(char));
    }
  }
  if (!SWIG_JavaArrayInInt(jenv, &jarr5, &arg5, jarg5)) return 0; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr6, &arg6, jarg6)) return 0; 
  result = (int)Get_iotypes(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = (jint)result; 
  SWIG_JavaArrayArgoutInt(jenv, jarr3, arg3, jarg3); 
  {
    int i;
    jstring temp_string;
    for(i = 0; i < len4; i++) {
      temp_string = (*jenv)->NewStringUTF(jenv, arg4[i]);
      (*jenv)->SetObjectArrayElement(jenv, jarg4, i, temp_string);
      (*jenv)->DeleteLocalRef(jenv, temp_string);
    }
  }
  SWIG_JavaArrayArgoutInt(jenv, jarr5, arg5, jarg5); 
  SWIG_JavaArrayArgoutInt(jenv, jarr6, arg6, jarg6); 
  free(arg3); 
  {
    int i;
    for(i = 0; i < len4; i++) 
    if(arg4[i]) free(arg4[i]);
    if(arg4) free(arg4);
  }
  free(arg5); 
  free(arg6); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1ChkType_1defs(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Consume_ChkType_defs(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1chktype_1number(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  result = (int)Get_chktype_number(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1chktypes(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jintArray jarg3, jobjectArray jarg4, jintArray jarg5, jintArray jarg6) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  char **arg4 = (char **) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int result;
  jint *jarr3 ;
  jint len4 ;
  jint *jarr5 ;
  jint *jarr6 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr3, &arg3, jarg3)) return 0; 
  {
    int i;
    if(!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    
    len4 = (*jenv)->GetArrayLength(jenv, jarg4);
    arg4 = (char**) malloc(len4 * sizeof(char*));
    for(i = 0; i < len4; i++) {
      arg4[i] = (char*) malloc(256 * sizeof(char));
    }
  }
  if (!SWIG_JavaArrayInInt(jenv, &jarr5, &arg5, jarg5)) return 0; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr6, &arg6, jarg6)) return 0; 
  result = (int)Get_chktypes(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = (jint)result; 
  SWIG_JavaArrayArgoutInt(jenv, jarr3, arg3, jarg3); 
  {
    int i;
    jstring temp_string;
    for(i = 0; i < len4; i++) {
      temp_string = (*jenv)->NewStringUTF(jenv, arg4[i]);
      (*jenv)->SetObjectArrayElement(jenv, jarg4, i, temp_string);
      (*jenv)->DeleteLocalRef(jenv, temp_string);
    }
  }
  SWIG_JavaArrayArgoutInt(jenv, jarr5, arg5, jarg5); 
  SWIG_JavaArrayArgoutInt(jenv, jarr6, arg6, jarg6); 
  free(arg3); 
  {
    int i;
    for(i = 0; i < len4; i++) 
    if(arg4[i]) free(arg4[i]);
    if(arg4) free(arg4);
  }
  free(arg5); 
  free(arg6); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1supp_1cmd_1number(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  result = (int)Get_supp_cmd_number(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1supp_1cmds(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jintArray jarg3) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  int result;
  jint *jarr3 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr3, &arg3, jarg3)) return 0; 
  result = (int)Get_supp_cmds(arg1,arg2,arg3);
  jresult = (jint)result; 
  SWIG_JavaArrayArgoutInt(jenv, jarr3, arg3, jarg3); 
  free(arg3); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1stop_1cmd(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Emit_stop_cmd(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1pause_1cmd(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Emit_pause_cmd(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1resume_1cmd(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jint jresult = 0 ;
  int arg1 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (int)Emit_resume_cmd(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1retrieve_1param_1log_1cmd(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  result = (int)Emit_retrieve_param_log_cmd(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1next_1message(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
  jint jresult = 0 ;
  int *arg1 = (int *) 0 ;
  int *arg2 = (int *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(int **)&jarg1; 
  arg2 = *(int **)&jarg2; 
  result = (int)Get_next_message(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Emit_1control(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jobjectArray jarg3, jobjectArray jarg4) {
  jint jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  char **arg4 = (char **) 0 ;
  int result;
  jint len3 ;
  jint len4 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  {
    if(!jarg3) {
      arg3 = NULL;
      len3 = 0;
    }
    else {
      len3 = (*jenv)->GetArrayLength(jenv, jarg3);
      arg3 = (int*) malloc(len3 * sizeof(int));
      (*jenv)->GetIntArrayRegion(jenv, jarg3, 0, (len3 - 1), arg3);
    }
  }
  {
    int i;
    if(!jarg4) {
      arg4 = NULL;
      len4 = 0;
    }
    else {
      len4 = (*jenv)->GetArrayLength(jenv, jarg4);
      arg4 = (char**) malloc((len4 + 1) * sizeof(char*));
      /* make a copy of each string */
      for(i = 0; i < len4; i++) {
        jstring jString = (jstring)(*jenv)->GetObjectArrayElement(jenv, jarg4, i);
        const char* cString = (*jenv)->GetStringUTFChars(jenv, jString, 0);
        arg4[i] = malloc(strlen((cString) + 1) * sizeof(const char*));
        strcpy(arg4[i], cString);
        (*jenv)->ReleaseStringUTFChars(jenv, jString, cString);
        (*jenv)->DeleteLocalRef(jenv, jString);
      }
      arg4[i] = 0;
    }
  }
  result = (int)Emit_control(arg1,arg2,arg3,arg4);
  jresult = (jint)result; 
  {
    if(arg3) free(arg3);
  }
  {
    int i;
    for(i = 0; i < len4-1; i++)
    if(arg4[i]) free(arg4[i]);
    if(arg4) free(arg4);
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1status(JNIEnv *jenv, jclass jcls, jint jarg1, jlong jarg2, jlong jarg3, jintArray jarg4) {
  jint jresult = 0 ;
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int result;
  jint *jarr4 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = *(int **)&jarg2; 
  arg3 = *(int **)&jarg3; 
  if (!SWIG_JavaArrayInInt(jenv, &jarr4, &arg4, jarg4)) return 0; 
  result = (int)Consume_status(arg1,arg2,arg3,arg4);
  jresult = (jint)result; 
  SWIG_JavaArrayArgoutInt(jenv, jarr4, arg4, jarg4); 
  free(arg4); 
  return jresult;
}


SWIGEXPORT jobject JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Consume_1data_1slice_1j(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jint jarg3) {
  jobject jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  jobject result;
  
  (void)jenv;
  (void)jcls;
  {
    /* Just throw outdata away from the inputs! */
  }
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    switch(arg2) {
    case 0:
      arg4 = (int*) malloc(arg3 * sizeof(int));
      break;
    case 3:
      arg4 = (char*) malloc(arg3 * sizeof(char));
      break;
    case 1:
      arg4 = (float*) malloc(arg3 * sizeof(float));
      break;
    case 2:
      arg4 = (double*) malloc(arg3 * sizeof(double));
      break;
    }
  }
  result = Consume_data_slice_j(arg1,arg2,arg3,arg4);
  jresult = result; 
  {
    jintArray iArray;
    jbyteArray bArray;
    jstring cString;
    jfloatArray fArray;
    jdoubleArray dArray;
    
    switch(arg2) {
    case 0:
      iArray = (*jenv)->NewIntArray(jenv, arg3);
      (*jenv)->SetIntArrayRegion(jenv, iArray, 0, arg3, arg4);
      jresult = iArray;
      break;
    case 3:
      if(((char*) arg4)[arg3 - 1] == '\0') {
        cString = (*jenv)->NewStringUTF(jenv, arg4);
        jresult = cString;
      }
      else {
        bArray = (*jenv)->NewByteArray(jenv, arg3);
        (*jenv)->SetByteArrayRegion(jenv, bArray, 0, arg3, arg4);
        jresult = bArray;
      }
      break;
    case 1:
      fArray = (*jenv)->NewFloatArray(jenv, arg3);
      (*jenv)->SetFloatArrayRegion(jenv, fArray, 0, arg3, arg4);
      jresult = fArray;
      break;
    case 2:
      dArray = (*jenv)->NewDoubleArray(jenv, arg3);
      (*jenv)->SetDoubleArrayRegion(jenv, dArray, 0, arg3, arg4);
      jresult = dArray;
      break;
    default:
      jresult = 0;
      break;
    }
    
  }
  {
    if(arg4) free(arg4);
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1param_1values_1j(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2, jint jarg3) {
  jobjectArray jresult = 0 ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  Param_details_struct *arg4 = (Param_details_struct *) 0 ;
  jobjectArray result;
  
  (void)jenv;
  (void)jcls;
  {
    /* Just throw outdata away from the inputs! */
  }
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  {
    arg4 = (Param_details_struct*) malloc(arg3 * sizeof(Param_details_struct));
  }
  result = Get_param_values_j(arg1,arg2,arg3,arg4);
  jresult = result; 
  {
    jclass regParam;
    jobjectArray paramArray;
    
    regParam = (*jenv)->FindClass(jenv, "org/realitygrid/steering/ReG_SteerParameter");
    paramArray = (*jenv)->NewObjectArray(jenv, arg3, regParam, NULL);
    
    if(arg3 > 0) {
      int i;
      jmethodID regParamCreate;
      jvalue args[7];
      jobject newObject;
      
      /* Set up access to the java classes and methods */
      regParamCreate = (*jenv)->GetStaticMethodID(jenv, regParam, "create", "(Ljava/lang/String;Ljava/lang/String;ZILjava/lang/String;Ljava/lang/String;I)Lorg/realitygrid/steering/ReG_SteerParameter;");
      
      for(i = 0; i < arg3; i++) {
        args[0].l = (*jenv)->NewStringUTF(jenv, arg4[i].label);
        args[1].l = (*jenv)->NewStringUTF(jenv, arg4[i].value);
        args[2].z = (arg2 == 1) ? JNI_TRUE : JNI_FALSE;
        args[3].i = arg4[i].type;
        args[4].l = (*jenv)->NewStringUTF(jenv, arg4[i].min_val);
        args[5].l = (*jenv)->NewStringUTF(jenv, arg4[i].max_val);
        args[6].i = arg4[i].handle;
        
        newObject = (*jenv)->CallStaticObjectMethodA(jenv, regParam, regParamCreate, args);
        (*jenv)->SetObjectArrayElement(jenv, paramArray, i, newObject);
      }
    }
    jresult = paramArray;
  }
  {
    if(arg4) free(arg4);
  }
  return jresult;
}


SWIGEXPORT jobject JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1security_1config_1j(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jobject jresult = 0 ;
  char *arg1 = (char *) 0 ;
  struct reg_security_info *arg2 = (struct reg_security_info *) 0 ;
  jobject result;
  
  (void)jenv;
  (void)jcls;
  {
    /* Just throw arg2 away from the inputs! */
  }
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  {
    arg2 = 0;
    arg2 = (struct reg_security_info*) malloc(sizeof(struct reg_security_info));
    if(!arg2) {
      return 0;
    }
  }
  result = Get_security_config_j((char const *)arg1,arg2);
  jresult = result; 
  {
    jclass regSec;
    jmethodID regSecCons;
    jvalue args[5];
    jobject newObject;
    
    regSec = (*jenv)->FindClass(jenv, "org/realitygrid/steering/ReG_SteerSecurity");
    regSecCons = (*jenv)->GetMethodID(jenv, regSec, "<init>", "(ZLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
    
    args[0].z = (arg2->use_ssl == 1) ? JNI_TRUE : JNI_FALSE;
    args[1].l = (*jenv)->NewStringUTF(jenv, arg2->caCertsPath);
    args[2].l = (*jenv)->NewStringUTF(jenv, arg2->myKeyCertFile);
    args[3].l = (*jenv)->NewStringUTF(jenv, arg2->userDN);
    args[4].l = (*jenv)->NewStringUTF(jenv, arg2->passphrase);
    
    newObject = (*jenv)->NewObjectA(jenv, regSec, regSecCons, args);
    
    jresult = newObject;
  }
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  {
    if(arg2) free(arg2);
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1registry_1entries_1secure_1j(JNIEnv *jenv, jclass jcls, jstring jarg1, jobject jarg2) {
  jobjectArray jresult = 0 ;
  char *arg1 = (char *) 0 ;
  struct reg_security_info *arg2 = (struct reg_security_info *) 0 ;
  struct registry_contents *arg3 = (struct registry_contents *) 0 ;
  jobjectArray result;
  
  (void)jenv;
  (void)jcls;
  {
    /* Just throw arg3 away from the inputs! */
  }
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  {
    jclass regSec;
    jmethodID getMethod;
    jboolean usingSSL;
    jboolean isStringCopy;
    jobject secString;
    const char* cString;
    
    // malloc C security struct
    arg2 = 0;
    arg2 = (struct reg_security_info*) malloc(sizeof(struct reg_security_info));
    if(!arg2) return 0;
    
    // get Java security class
    regSec = (*jenv)->FindClass(jenv, "org/realitygrid/steering/ReG_SteerSecurity");
    
    // use_ssl?
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "isUsingSSL", "()Z");
    usingSSL = (*jenv)->CallBooleanMethod(jenv, jarg2, getMethod);
    arg2->use_ssl = (usingSSL == JNI_TRUE) ? 1 : 0;
    
    // caCertsPath
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getCaCertsPath", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->caCertsPath, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // myKeyCertFile
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getMyKeyCertFile", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->myKeyCertFile, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // userDN
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getUserDN", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->userDN, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // passphrase
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getPassphrase", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->passphrase, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
  }
  {
    arg3 = 0;
    arg3 = (struct registry_contents*) malloc(sizeof(struct registry_contents));
    if(!arg3) {
      return 0;
    }
  }
  result = Get_registry_entries_secure_j((char const *)arg1,(struct reg_security_info const *)arg2,arg3);
  jresult = result; 
  {
    int num = arg3->numEntries;
    jclass regEntry;
    jobjectArray entryArray;
    
    regEntry = (*jenv)->FindClass(jenv, "org/realitygrid/steering/ReG_SteerRegistryEntry");
    entryArray = (*jenv)->NewObjectArray(jenv, num, regEntry, NULL);
    
    if(num > 0) {
      int i;
      jmethodID regEntryCons;
      jvalue args[8];
      jobject newObject;
      
      regEntryCons = (*jenv)->GetMethodID(jenv, regEntry, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
      
      for(i = 0; i < num; i++) {
        args[0].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].service_type);
        args[1].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].gsh);
        args[2].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].entry_gsh);
        args[3].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].application);
        args[4].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].start_date_time);
        args[5].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].user);
        args[6].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].group);
        args[7].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].job_description);
        
        newObject = (*jenv)->NewObjectA(jenv, regEntry, regEntryCons, args);
        (*jenv)->SetObjectArrayElement(jenv, entryArray, i, newObject);
      }
    }
    
    jresult = entryArray;
  }
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  {
    if(arg2) free(arg2);
  }
  {
    if(arg3) {
      Delete_registry_table(arg3);
      free(arg3);
    }
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_org_realitygrid_steering_ReG_1SteerJNI_Get_1registry_1entries_1filtered_1secure_1j(JNIEnv *jenv, jclass jcls, jstring jarg1, jobject jarg2, jstring jarg4) {
  jobjectArray jresult = 0 ;
  char *arg1 = (char *) 0 ;
  struct reg_security_info *arg2 = (struct reg_security_info *) 0 ;
  struct registry_contents *arg3 = (struct registry_contents *) 0 ;
  char *arg4 = (char *) 0 ;
  jobjectArray result;
  
  (void)jenv;
  (void)jcls;
  {
    /* Just throw arg3 away from the inputs! */
  }
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
    if (!arg1) return 0;
  }
  {
    jclass regSec;
    jmethodID getMethod;
    jboolean usingSSL;
    jboolean isStringCopy;
    jobject secString;
    const char* cString;
    
    // malloc C security struct
    arg2 = 0;
    arg2 = (struct reg_security_info*) malloc(sizeof(struct reg_security_info));
    if(!arg2) return 0;
    
    // get Java security class
    regSec = (*jenv)->FindClass(jenv, "org/realitygrid/steering/ReG_SteerSecurity");
    
    // use_ssl?
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "isUsingSSL", "()Z");
    usingSSL = (*jenv)->CallBooleanMethod(jenv, jarg2, getMethod);
    arg2->use_ssl = (usingSSL == JNI_TRUE) ? 1 : 0;
    
    // caCertsPath
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getCaCertsPath", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->caCertsPath, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // myKeyCertFile
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getMyKeyCertFile", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->myKeyCertFile, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // userDN
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getUserDN", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->userDN, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
    
    // passphrase
    getMethod = (*jenv)->GetMethodID(jenv, regSec, "getPassphrase", "()Ljava/lang/String;");
    secString = (*jenv)->CallObjectMethod(jenv, jarg2, getMethod);
    cString = (*jenv)->GetStringUTFChars(jenv, (jstring) secString, &isStringCopy);
    strncpy(arg2->passphrase, cString, 256);
    if(isStringCopy == JNI_TRUE) {
      (*jenv)->ReleaseStringUTFChars(jenv, secString, cString);
    }
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg4, 0);
    if (!arg4) return 0;
  }
  {
    arg3 = 0;
    arg3 = (struct registry_contents*) malloc(sizeof(struct registry_contents));
    if(!arg3) {
      return 0;
    }
  }
  result = Get_registry_entries_filtered_secure_j((char const *)arg1,(struct reg_security_info const *)arg2,arg3,arg4);
  jresult = result; 
  {
    int num = arg3->numEntries;
    jclass regEntry;
    jobjectArray entryArray;
    
    regEntry = (*jenv)->FindClass(jenv, "org/realitygrid/steering/ReG_SteerRegistryEntry");
    entryArray = (*jenv)->NewObjectArray(jenv, num, regEntry, NULL);
    
    if(num > 0) {
      int i;
      jmethodID regEntryCons;
      jvalue args[8];
      jobject newObject;
      
      regEntryCons = (*jenv)->GetMethodID(jenv, regEntry, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
      
      for(i = 0; i < num; i++) {
        args[0].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].service_type);
        args[1].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].gsh);
        args[2].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].entry_gsh);
        args[3].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].application);
        args[4].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].start_date_time);
        args[5].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].user);
        args[6].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].group);
        args[7].l = (*jenv)->NewStringUTF(jenv, arg3->entries[i].job_description);
        
        newObject = (*jenv)->NewObjectA(jenv, regEntry, regEntryCons, args);
        (*jenv)->SetObjectArrayElement(jenv, entryArray, i, newObject);
      }
    }
    
    jresult = entryArray;
  }
  if (arg1) (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
  {
    if(arg2) free(arg2);
  }
  {
    if(arg3) {
      Delete_registry_table(arg3);
      free(arg3);
    }
  }
  if (arg4) (*jenv)->ReleaseStringUTFChars(jenv, jarg4, (const char *)arg4);
  return jresult;
}


#ifdef __cplusplus
}
#endif

